//
// Created by marcel on 16.07.18.
//

#ifndef FICTION_COMMANDS_H
#define FICTION_COMMANDS_H

#include "version.h"
#include "exact_pr.h"
#include "orthogonal_pr.h"
#include "design_checker.h"
#include "fcn_gate_layout.h"
#include "fcn_cell_layout.h"
#include "qca_one_library.h"
#include "equivalence_checker.h"
#include "json_parser.h"
#include "json_writer.h"
#include "qca_writer.h"
#include <boost/filesystem.hpp>
#include <boost/range/iterator_range.hpp>
#include <alice/alice.hpp>
#include <mockturtle/io/verilog_reader.hpp>

namespace alice
{
    /**
     * Outputs version and build information.
     */
    class version_command : public command
    {
    public:
        /**
         * Standard constructor. Adds descriptive information, options, and flags.
         *
         * @param env alice::environment that specifies stores etc.
         */
        explicit version_command(const environment::ptr& env)
                :
                command(env, "Outputs the version string as well as build time and date.")
        {}

    protected:
        /**
         * Function to perform the version print call.
         */
        void execute() override
        {
            env->out() << VERSION << " - compiled on " << COMPILED_DATE << " at " << COMPILED_TIME << std::endl;
        }
    };

    ALICE_ADD_COMMAND(version, "General")


    /**
     * Shorthand for all read commands. Chooses the proper function by the file ending.
     *
     * Parses verilog files currently. Gate level netlists are supported. The lorina verilog parser is used. At the
     * moment, only 2-input gates + 3-input MAJ in assign notation are supported. Using ABC, those can be generated by
     * the commands
     *
     * read <file>
     * strash
     * write <file>.v
     *
     * For more information see: https://github.com/marcelwa/lorina
     */
    class read_command : public command
    {
    public:
        /**
         * Standard constructor. Adds descriptive information, options, and flags.
         *
         * @param env alice::environment that specifies stores etc.
         */
        explicit read_command(const environment::ptr& env)
                :
                command(env, "Reads one Verilog file or a directory of those and creates logic network objects which will be put "
                             "into the respective store. The same works for JSON files from which logic network and gate layout "
                             "objects are generated. In a directory, only files with extensions '.v' and '.json' are considered.")
        {
            add_option("filename", filename,
                       "Verilog or JSON filename or directory of Verilog or JSON files")->required();
            add_flag("--sort,-s", sort,
                       "Sort files in given directory by file size prior to parsing");
        }

    protected:
        /**
         * Function to perform the read call. Reads Verilog and creates a logic_network or reads JSON and creates
         * logic_network and gate_layout.
         */
        void execute() override
        {
            // checks for extension validity
            auto is_valid_extension = [](const auto& _f) -> bool
            {
                const std::vector<std::string> extensions{{".v"}, {".json"}};
                return std::any_of(extensions.cbegin(), extensions.cend(),
                                   [&_f](const auto& _e) { return boost::filesystem::extension(_f) == _e; });
            };

            // check for for given file's properties
            if (boost::filesystem::exists(filename))
            {
                if (boost::filesystem::is_regular_file(filename))
                {
                    // collect valid files only
                    if (is_valid_extension(filename))
                        paths.push_back(filename);
                }

                else if (boost::filesystem::is_directory(filename))
                {
                    // iterate over each file in the directory
                    for (auto& file : boost::make_iterator_range(boost::filesystem::directory_iterator(filename), {}))
                    {
                        if (boost::filesystem::is_regular_file(file))
                        {
                            // collect valid files only
                            if (is_valid_extension(file))
                                paths.push_back(file.path().string());
                        }
                    }
                }
                else // existing file but a weird one
                    env->out() << "[e] given file name does not point to a regular file" << std::endl;
            }
            else // path leads nowhere
                env->out() << "[e] given file name does not exist" << std::endl;

            // sort by file size to make the small ones go first
            if (sort)
            {
                std::sort(paths.begin(), paths.end(), [](std::string& f1, std::string& f2)
                { return boost::filesystem::file_size(f1) >= boost::filesystem::file_size(f2); });
            }

            // handle collected files
            for (const auto& f : paths)
            {
                // parse Verilog
                if (boost::filesystem::extension(f) == ".v")
                {
                    read_verilog(f);
                }
                // parse ...
                // else if (boost::filesystem::extension(f) == ...)
                else if(boost::filesystem::extension(f) == ".json")
                {
                    //std::cout << "Trying to read JSON" << std::endl;
                    read_json(f);
                }
            }

            // reset flags, necessary for some reason... alice bug?
            paths = {};
            sort = false;
        }

    private:
        /**
         * Handles creation of a logic_network object from the given Verilog file.
         *
         * @param f Path to the Verilog file to read
         */
        void read_verilog(std::string f)
        {
            auto name = boost::filesystem::path{f}.stem().string();
                    logic_network ln{std::move(name)};

                    if (lorina::diagnostic_engine diag{};
                        lorina::read_verilog(f, mockturtle::verilog_reader{ln}, &diag) == lorina::return_code::success)
                    {
                        ln.substitute();
                        store<logic_network_ptr>().extend() = std::make_shared<logic_network>(std::move(ln));
                    }
                    else
                    {
                        env->out() << "[e] parsing error in " << f << std::endl;
                    }
        }
        /**
         * Handles creation of logic_network and fcn_gate_layout objects from the given JSON file.
         *
         * @param f Path to the JSON file to read
         */
        void read_json(std::string f)
        {
            auto name = boost::filesystem::path{f}.stem().string();
            auto ln = std::make_shared<logic_network>(std::move(name));
            std::shared_ptr<fcn_gate_layout> fgl;
            std::shared_ptr<fcn_gate_library> fglib;
            try {
                json_parser parser(f, ln, fgl);
                parser.parse();
            } catch (const std::invalid_argument &ex) {
                std::cout << "[e] " << ex.what() << std::endl;
            }

            store<logic_network_ptr>().extend() = ln;

            store<fcn_gate_layout_ptr>().extend() = fgl;
        }
        /**
         * Verilog filename.
         */
        std::string filename;
        /**
         * All paths found under filename.
         */
        std::vector<std::string> paths{};
        /**
         * Flag to indicate that files should be sorted by file size.
         */
         bool sort = false;
    };

    ALICE_ADD_COMMAND(read, "I/O")

   /**
    * Clears all stores by removing all their entries.
    */
    class clear_command : public command
    {
    public:
        /**
         * Standard constructor. Adds descriptive information, options, and flags.
         *
         * @param env alice::environment that specifies stores etc.
         */
        explicit clear_command(const environment::ptr& env)
                :
                command(env,
                        "Removes all elements from the respectively flagged stores. If no store is specified, all "
                        "stores will be cleared.")
        {
            add_flag("--logic_network,-w", network,
                     "Clear logic network store");
            add_flag("--gate_layout,-g", gate,
                     "Clear gate layout store");
            add_flag("--cell_layout,-c", cell,
                     "Clear cell layout store");
        }

    protected:
        /**
         * Function to perform the clear call. Calls alice's clear function for all stores.
         */
        void execute() override
        {
            // if no store was specified, clear all.
            if (!cell && !gate && !network)
            {
                cell = true; gate = true; network = true;
            }

            if (cell)
                store<fcn_cell_layout_ptr>().clear();
            if (gate)
                store<fcn_gate_layout_ptr>().clear();
            if (network)
                store<logic_network_ptr>().clear();

            // reset flags, necessary for some reason... alice bug?
            cell = false; gate = false; network = false;
        }

    private:
        /**
         * Stores to clear.
         */
        bool cell = false, gate = false, network = false;
    };

    ALICE_ADD_COMMAND(clear, "General")


    /**
     * Executes an exact placement and routing approach utilizing the SMT solver Z3.
     * See exact_pr.h for more details.
     */
    class exact_command : public command
    {
    public:
        /**
         * Standard constructor. Adds descriptive information, options, and flags.
         *
         * @param env alice::environment that specifies stores etc.
         */
        explicit exact_command(const environment::ptr& env)
                :
                command(env, "Performs exact placement and routing of the current logic network in store. "
                             "A minimum FCN layout will be found that meets all given constraints.")
        {
            add_option("--clocking_scheme,-s", clocking,
                       "Clocking scheme to be used {OPEN3, OPEN4, 2DDWAVE3, 2DDWAVE4, USE, RES, BANCS}", true);
            add_option("--upper_bound,-u", config.upper_bound,
                       "Number of FCN gate tiles to use at maximum");
            add_option("--limit_crossings,-c", config.crossings_limit,
                       "Maximum number of tiles to use for crossings");
            add_option("--limit_wires,-w", config.wire_limit,
                       "Maximum number of wire elements per connection");
            add_option("--timeout,-t", config.timeout,
                       "Timeout in milliseconds");

            add_flag("--crossings,-x", config.crossings,
                     "Enable second layer for wire crossings");
            add_flag("--io_ports,-i", config.io_ports,
                     "Route extra wires to balance I/O port paths");
            add_flag("--border_io,-b", config.border_io,
                     "Enforce primary I/O to be placed at the layout's borders");
            add_flag("--path_discrepancy,-p", config.path_discrepancy,
                     "Allow a discrepancy in fan-in paths (area vs. throughput)");
            add_flag("--artificial_latch,-a", config.artificial_latch,
                     "Allow clocked latch delays to balance fan-in paths");
            add_flag("--fixed_size,-f", config.fixed_size,
                     "Execute only one run with upper_bound given as a fixed size");
        }

    protected:
        /**
         * Function to perform the P&R call. Given arguments are parsed and a FCN gate layout is generated if possible.
         */
        void execute() override
        {
            auto& s = store<logic_network_ptr>();

            // error case: empty logic network store
            if (s.empty())
            {
                env->out() << "[w] no logic network in store" << std::endl;
                reset_flags();
                return;
            }

            // error case: -f is set but -u is not
            if (this->is_set("fixed_size") && !this->is_set("upper_bound"))
            {
                env->out() << "[e] -u must be defined as well when -f is used" << std::endl;
                reset_flags();
                return;
            }

            // choose clocking
            if (auto clk = get_clocking_scheme(clocking))
            {
                config.scheme = std::make_shared<fcn_clocking_scheme>(*clk);
            }
            else
            {
                env->out() << "[e] \"" << clocking << "\" does not refer to a supported clocking scheme" << std::endl;
                reset_flags();
                return;
            }

            // perform exact P&R
            exact_pr pr{s.current(), std::move(config)};

            if (auto result = pr.perform_place_and_route(); result.success)
            {
                store<fcn_gate_layout_ptr>().extend() = pr.get_layout();
                pr_result = result.json;
            }
            else
                env->out() << "[e] impossible to place and route " << s.current()->get_name() << " within the given "
                              "parameters" << std::endl;


            reset_flags();
        }
        /**
         * Logs the resulting information in a log file.
         *
         * @return JSON object containing information about the solving process.
         */
        nlohmann::json log() const override
        {
            return pr_result;
        }
        /**
         * Reset all flags. Necessary for some reason... alice bug?
         */
        void reset_flags()
        {
            config = exact_pr_config{};
            clocking = "OPEN4";
        }

    private:
        /**
         * Configuration object extracted from arguments and flags.
         */
        exact_pr_config config{};
        /**
         * Identifier of clocking scheme to use.
         */
        std::string clocking = "OPEN4";
        /**
         * Resulting logging information.
         */
        nlohmann::json pr_result;
    };

    ALICE_ADD_COMMAND(exact, "Placement & Routing")


    /**
     * Executes a heuristic placement and routing approach based on "Improved Orthogonal Drawing of 3-graphs" by
     * Therese Biedl, 1996.
     * See orthogonal_pr.h for more details.
     */
    class ortho_command : public command
    {
    public:
        /**
         * Standard constructor. Adds descriptive information, options, and flags.
         *
         * @param env alice::environment that specifies stores etc.
         */
        explicit ortho_command(const environment::ptr& env)
                :
                command(env, "Performs heuristic placement and routing of the current logic network in store. "
                             "An FCN layout that is not minimal will be found in reasonable runtime.")
        {
            add_option("--clock_numbers,-n", phases,
                       "Number of clock phases to be used {3 or 4}", true);
            add_flag("--io_ports,-i", io_ports,
                     "Place designated I/O ports too");
        }

    protected:
        /**
         * Function to perform the P&R call. Generates an FCN gate layout.
         */
        void execute() override
        {
            auto& s = store<logic_network_ptr>();

            // error case: empty logic network store
            if (s.empty())
            {
                env->out() << "[w] no logic network in store" << std::endl;
                reset_flags();
                return;
            }
            // error case: phases out of range
            if (phases != 3u && phases != 4u)
            {
                env->out() << "[e] only 3- and 4-phase clocking schemes are supported" << std::endl;
                reset_flags();
                return;
            }

            // perform heuristic P&R
            orthogonal_pr pr{s.current(), phases, io_ports};

            if (auto result = pr.perform_place_and_route(); result.success)
            {
                store<fcn_gate_layout_ptr>().extend() = pr.get_layout();
                pr_result = result.json;
            }
            else
                env->out() << "[e] impossible to place and route " << s.current()->get_name() << std::endl;

            reset_flags();
        }
        /**
         * Logs the resulting information in a log file.
         *
         * @return JSON object containing information about the P&R process.
         */
        nlohmann::json log() const override
        {
            return pr_result;
        }
        /**
         * Reset all flags. Necessary for some reason... alice bug?
         */
        void reset_flags()
        {
            phases = 4u;
            io_ports = false;
        }

    private:
        /**
         * Number of clock phases to use. 3 and 4 are supported.
         */
        unsigned phases = 4u;
        /**
         * Flag to indicate that designated I/O ports should be placed.
         */
        bool io_ports = false;
        /**
         * Resulting logging information.
         */
        nlohmann::json pr_result;
    };

    ALICE_ADD_COMMAND(ortho, "Placement & Routing")


    /**
     * Performs design rule checks on the active gate layout. Checks for various design rule validations like crossing
     * gates, too many wires in a tile, wrongly assigned directions, etc.
     * See design_checker.h for more details.
     */
    class check_command : public command
    {
    public:
        /**
         * Standard constructor. Adds descriptive information, options, and flags.
         *
         * @param env alice::environment that specifies stores etc.
         */
        explicit check_command(const environment::ptr& env)
                :
                command(env, "Performs various design rule checks on the current gate layout in store. "
                             "A full report can be logged and a summary is printed to standard output.")
        {
            add_option("--wire_limit,-w", wire_limit,
                       "Maximum number of wires allowed per tile", true);
        }

    protected:
        /**
         * Function to perform the design rule check call. Generates a report and prints a summary.
         */
        void execute() override
        {
            auto& s = store<fcn_gate_layout_ptr>();

            // error case: empty logic network store
            if (s.empty())
            {
                env->out() << "[w] no gate layout in store" << std::endl;
                reset_flags();
                return;
            }

            design_checker c{s.current(), std::move(wire_limit)};
            report = c.check(env->out());

            reset_flags();
        }

        /**
         * Logs the resulting information in a log file.
         *
         * @return JSON object containing information about the P&R process.
         */
        nlohmann::json log() const override
        {
            return report;
        }

        /**
         * Reset all flags. Necessary for some reason... alice bug?
         */
        void reset_flags()
        {
            wire_limit = 1;
        }

    private:
        /**
         * Resulting logging information.
         */
        nlohmann::json report;
        /**
         * Maximum number of wires per tile.
         */
        std::size_t wire_limit = 1;
    };

    ALICE_ADD_COMMAND(check, "Verification")


    /**
     * Converts an fcn_gate_layout to an fcn_cell_layout. Conversion process allows to choose from supported FCN gate
     * libraries.
     */
    class cell_command : public command
    {
    public:
        /**
         * Standard constructor. Adds descriptive information, options, and flags.
         *
         * @param env alice::environment that specifies stores etc.
         */
        explicit cell_command(const environment::ptr& env)
                :
                command(env, "Converts the current gate layout in store to a cell layout. A gate library must be "
                             "specified in order to instruct the algorithm how to map gate tiles to cell tiles.")
        {
            add_option("--library,-l", library,
                       "Gate library to use {QCA-ONE=0}", true);
        }

    protected:
        /**
         * Function to perform the conversion call. Generates an fcn_cell_layout.
         */
        void execute() override
        {
            auto& s = store<fcn_gate_layout_ptr>();

            // error case: empty gate layout store
            if (s.empty())
            {
                env->out() << "[w] no gate layout in store" << std::endl;
                return;
            }

            fcn_gate_library_ptr lib = nullptr;
            std::string lib_name{};
            try
            {
                if (library == 0u)
                    lib = std::make_shared<qca_one_library>(s.current());
                // else if (library == 1u)
                    // more libraries go here
                else
                {
                    env->out() << "[e] identifier " << library << " does not refer to a supported gate library" << std::endl;
                    return;
                }

                lib_name = lib->get_name();
            }
            catch (...)
            {
                env->out() << "[e] could not assign directions in " << s.current()->get_name() << " to cell ports" << std::endl;
                return;
            }

            fcn_cell_layout_ptr fcl = nullptr;
            try
            {
                fcl = std::make_shared<fcn_cell_layout>(std::move(lib));
            }
            catch (...)
            {
                env->out() << "[e] mapping " << s.current()->get_name() << " to a cell layout using the "
                    << lib_name << " library was not successful" << std::endl;
                return;
            }

            // store new layout
            store<fcn_cell_layout_ptr>().extend() = std::move(fcl);
        }

    private:
        /**
         * Identifier of gate library to use.
         */
        unsigned library = 0u;
    };

    ALICE_ADD_COMMAND(cell, "Conversion")

    /**
     * Generates a QCADesigner file for the current cell layout in store and writes it to the given path.
     *
     * QCADesigner is available at: https://waluslab.ece.ubc.ca/qcadesigner/
     */
    class qca_command : public command
    {
    public:
        /**
         * Standard constructor. Adds descriptive information, options, and flags.
         *
         * @param env alice::environment that specifies stores etc.
         */
        explicit qca_command(const environment::ptr& env)
                :
                command(env, "Generates a QCADesigner file for the current cell layout in store to perform "
                             "physical simulations.")
        {
            add_option("filename", filename,
                       "QCA file name");
        }

    protected:
        /**
         * Function to perform the output print call. Generates a QCADesigner file.
         */
        void execute() override
        {
            auto s = store<fcn_cell_layout_ptr>();

            // error case: empty cell layout store
            if (s.empty())
            {
                env->out() << "[w] no cell layout in store" << std::endl;
                return;
            }
            // error case: do not override directories
            if (boost::filesystem::is_directory(filename))
            {
                env->out() << "[e] cannot override a directory" << std::endl;
                return;
            }
            // if filename was empty or not given, use stored layout name
            if (filename.empty())
                filename = s.current()->get_name();
            // add .qca file extension if necessary
            if (boost::filesystem::extension(filename) != ".qca")
                filename += ".qca";

            qca::write(std::move(s.current()), filename);
        }

    private:
        /**
         * File name to write the QCA file into.
         */
        std::string filename;
    };

    ALICE_ADD_COMMAND(qca, "I/O")

    /**
     * Generates a JSON representation of the current gate or cell layout, depending on arguments.
     * JSON format of layouts is based on
     */
    class export_command : public command
    {
    public:
        /**
         * Standard constructor. Adds descriptive information, options, and flags.
         *
         * @param env alice::environment that specifies stores etc.
         */
        export_command(const environment::ptr& env)
                :
                command(env, "Generates a JSON description of a cell or gate layout and writes it to a file.")
        {
            add_option("--library,-l", library,
                       "Gate library to use {QCA-ONE=0}", true);
            add_option("--file,-f", filename,
                       "File to write export to", true);
            add_flag("-g", "Export gate layout from store");
            add_flag("-c", "Export cell layout from store");
        }

    protected:
        /**
         * Function to perform the export-to-json call. Generates a JSON-description of the current gate or cell layout,
         * depending on given arguments.
         */
        void execute() override
        {
            if (is_set("-g"))
            {
                auto s = store<fcn_gate_layout_ptr>();

                // error case: empty gate layout store
                if (s.empty())
                {
                    std::cout << "[e] no gate layout in store" << std::endl;
                    return;
                }

                fcn_gate_library_ptr lib = nullptr;

                if (library == 0u)
                    lib = std::make_shared<qca_one_library>(std::move(s.current()));
                    // else if (library == 1u)
                    // more libraries go here
                else
                {
                    std::cout << "[e] identifier " << library << " does not refer to a supported gate library"
                              << std::endl;
                    return;
                }

                // The validity rules ensure that this works the way it is intended
                json_writer exporter{lib};

                try
                {
                    exported_layout = exporter.export_gate_layout();
                }
                catch (const std::invalid_argument& e)
                {
                    std::cout << "[e] " << e.what() << std::endl;
                }

            }
            else if (is_set("-c"))
            {
                auto s = store<fcn_cell_layout_ptr>();

                if (s.empty())
                {
                    std::cout << "[e] No cell layout in store!" << std::endl;
                    return;
                }

                json_writer exporter{s.current()};

                try
                {
                    exported_layout = exporter.export_cell_layout();
                }
                catch (std::invalid_argument& e)
                {
                    std::cout << "[e] " << e.what() << std::endl;
                }

            }

            std::ofstream fs{};
            fs.open(filename, std::ios::out | std::ios::trunc);

            if (fs.fail())
            {
                std::cout << "[e] Could not open file " << filename << std::endl;
                return;
            }

            fs << log() << std::endl;
        }

        /**
         * This enforces rules for the flags given to the export command. Exactly one flag has to be set. The
         * corresponding store cannot be empty.
         */
        rules validity_rules() const override
        {
            rule rule{};

            if (is_set("-g"))
                rule = has_store_element<fcn_gate_layout_ptr>(env);
            else if (is_set("-c"))
                rule = has_store_element<fcn_cell_layout_ptr>(env);
            else
                rule = std::make_pair([]() { return false; }, "either -g or -c need to be set");

            return { rule, { [this]() { return is_set("-g") != is_set("-c"); }, "not both -g and -c can be set!" } };
        }

        /**
         * Logs the resulting information in a log file.
         *
         * @return JSON object containing information about the P&R process.
         */
        nlohmann::json log() const override
        {
            return exported_layout;
        }

    private:
        /**
         * Gate or cell layout exported in JSON.
         */
        nlohmann::json exported_layout;
        /**
         * Identifier of gate library to use.
         */
        unsigned library = 0u;
        /**
         * Standard filename in case none is specified.
         */
        std::string filename = "./fiction_export.json";
    };

    ALICE_ADD_COMMAND(export, "I/O")

    /**
     * Performs equality checks on logic networks; either between specification and gate layout or between two gate
     * layouts.
     */
    class equiv_command : public command
    {
    public:
        /**
         * Standard constructor. Adds descriptive information, options, and flags.
         *
         * @param env alice::environment that specifies stores etc.
         */
        equiv_command(const environment::ptr& env)
                :
                command(env, "Performs equivalence checks; either between specification and gate layout "
                             "or between two gate layouts.")
        {
            add_option("--gate,-g", gli,
                       "Gate layout to compare the current one against", false);
            add_option("--faults,-f", faults,
                       "Maximum number of faults to randomly insert into the circuit", true);
        }

    protected:
        /**
         * Function to perform the equivalence check. Differentiation between both modes is based on parameters given to
         * the command-call.
         */
        void execute() override
        {
            auto s = store<fcn_gate_layout_ptr>();
            if (s.empty())
            {
                std::cout << "[e] no gate layout in store" << std::endl;
                return;
            }

            fgl1 = s.current();

            std::string equivalent;

            // check whether an index was given
            if (gli >= 0)
            {
                // try accessing store at given index
                try
                {
                    fgl2 = s[gli];
                }
                catch (...)
                {
                    std::cout << "[e] no gate layout in store at index " << gli << std::endl;
                    return;
                }

                // check gate layouts for equality because network comparison is trivial in that case
                if (fgl1 == fgl2)
                {
                    std::cout << "[e] gate layouts to compare are equal" << std::endl;
                    return;
                }

                // create comparator
                equivalence_checker nc{fgl1, fgl2, faults};
                // and perform equivalence check
                try
                {
                    result = nc.check();
                }
                catch (std::invalid_argument& e)
                {
                    std::cout << "[e] " << e.what() << std::endl;
                }

            }
            else
            {
                equivalence_checker nc{fgl1, faults};
                result = nc.check();
            }

            auto[cp, tp] = fgl1->critical_path_length_and_throughput();

            std::cout << "[i] the circuits are " << (result.result ? (tp > 1 ? "weak " : "strong ") : "not ")
                      << "equivalent" << (tp > 1 ? fmt::format(" (after {} clock cycles)", tp) : "") << std::endl;

            // reset index for future calls
            gli = -1;
            faults = 0;
        }

        /**
         * Logs the resulting information in a log file.
         *
         * @return JSON object containing information about the equivalence checking process.
         */
        nlohmann::json log() const override
        {
            return result.json;
        }

    private:
        /**
         * Index of gate layout that current gate layout is to be compared against.
         */
        int gli = -1;
        /**
         * Number of faults to be inserted.
         */
        std::size_t faults = 0;
        /**
         * Gate layout pointers for comparison of logic networks.
         */
        fcn_gate_layout_ptr fgl1, fgl2;
        /**
         * Stores the result of the last equivalence check for easier access to result and logging data.
         */
        equivalence_checker::check_result result;
    };

    ALICE_ADD_COMMAND(equiv, "Verification")
}


#endif //FICTION_COMMANDS_H
